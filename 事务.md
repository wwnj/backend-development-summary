# 1.事务

## 1.1事务特性ACID

原子性（Atomic）：在同一个事务中，对多项数据的修改要么同时成功，要么撤销修改
一致性（Consistency）：所有数据符合期望，不会因为运行而导致互相矛盾
持久性（Durability）：事务一旦执行成功，对数据的修改是永久的；异常时通过Redo Log修复
隔离性（Isolation）：多个事务互相隔离，不影响各自的数据；“读-写”通过MVCC保证，“写-写”通过加锁保证

## 1.2本地事务

单个服务使用单个数据源的场景

### 1.2.1实现原子性和持久性

实现原子性和持久性的最大困难是“内存数据写入磁盘”这个操作不是原子的。

**Commit Logging**（提交日志）：事务的所有操作以日志的形式——仅进行顺序追加的文件写入，先写入磁盘。数据库在日志中看到代表事务成功提交的“提交记录”（Commit Record）后，才会根据日志上的的信息对数据进行真正的修改，修改完成后再在日志中追加一条“结束记录”（End Record）。
发生崩溃时，如果事务日志不存在Commit Record则根据日志回滚；如果存在Commit Record则根据已写入磁盘中的日志恢复现场，继续修改数据。
Commit Logging只能在日志中已写入Commit Record才能真正的修改磁盘数据，在此之前，即使磁盘IO空闲，即使事务修改的磁盘数据非常大，占用大量的内存缓存，也不能提前修改磁盘数据。
代表：阿里的OceanBase

**Write-Ahead Logging**（提前写入日志）：为了解决上述问题，可以使用ARIES理论提出的Write-Ahead Logging的日志改进方案。允许在事务提交之前，提前写入变动数据。
Write-Ahead Logging将何时写入磁盘数据，按照事务提交时为界，分为FORCE和STEAL两种：
FORCE：当提交事务后，必须同时持久化数据到磁盘称为FORCE。实际上数据库大多采用NO-FORCE，只要有了日志，随时可以持久化数据，从优化磁盘IO考虑，没必要强制数据立即进行。
STEAL：在事务提交前，允许提前写入变动数据至磁盘的方式称为STEAL。
Commit Logging允许NO-FORCE，不允许STEAL；Write-Ahead Logging允许NO-FORCE、允许STEAL。
Redo Log（重做日志）：用于崩溃时重演数据变动的日志
 Undo Log（回滚日志）：用于事务回滚或者崩溃时对提前写入磁盘的数据进行擦除

### 1.2.2实现隔离性

隔离性保证了各个事务各自读、写的数据相互独立。

写锁：Wirte Lock，也叫做排它锁，eXclusive Lock，简写X-Lock
读锁：Read Lock，也叫做共享锁，Shared Lock，简写S-Lock
范围锁：Range Lock，对某个范围直接加排它锁；它不等于一组排他锁的集合，因为加了范围锁后，不仅无法修改该范围内已有的数据，也不能再该范围内新增或删除任何数据

事务隔离级别：
可串行化：串行执行事务，无需加锁。
可重复读：对事务涉及的数据施加读锁和写锁，不施加范围锁。无法解决**幻读**问题
读已提交：对事务涉及的数据施加写锁，查询时施加读锁，读完释放，不一直持有读锁。存在**不可重复读**问题
读未提交：对事务涉及的数据施加写锁，不加读锁。无法解决**脏读**问题
以上四种隔离级别场景都有一个共性：一个事务读受另一个事务写影响而破坏了隔离性。针对**“一个事务读+一个事务写”**的隔离问题，商业数据库采用**多版本并发控制**（Multi-Version Concurrency Control，MVCC）的无锁优化方案。

MVCC是一种读取优化策略，它的“无锁”是指读取时可以完全不用加锁。每一行记录都存在两个看不见的字段：CREATE_VERSION、DELETE_VERSION，这两个字段记录的值都是事务ID，事务ID是一个全局严格递增的数据，根据以下规则写入：

- 插入数据时：CREATE_VERSION字段记录事务ID，DELETE_VERSION为空
- 删除数据时：DELETE_VERSION字段记录事务ID，CREATE_VERSION为空
- 修改数据时：新增一条记录，CREATE_VERSION记录事务ID，DELETE_VERSION为空；原数据DELETE_VERSION记录事务ID

此时，事务查询数据时由事务隔离级别来决定到底读取哪个版本的数据：
可重复读：查询数据时，只查询CREATE_VERSION小于等于当前事务ID，如果数据有多个版本，则选择事务ID最大的
读已提交：直接查询CREATE_VERSION字段事务ID最大的记录
可串行化、读未提交：不需要版本控制

对于**“写+写”**场景，只能加锁实现事务隔离。
悲观锁：Pessimistic Locking，访问数据前先加锁
乐观锁：Optimistic Locking，访问数据前不加锁，有竞争在补救措施

### 1.2.3实现一致性

实现了原子性、持久性、隔离性，就实现了一致性；前者是因，后者是果

## 1.3全局事务

单服务多个数据源的场景